
---------------------------------------------------------------------------------------------------------
	序号	|		名称	  |		内容
---------------------------------------------------------------------------------------------------------
			|				  |		定义：确保某一个类只有一个实例，并自行实例化向整个系统提供这个实例		
			|				  |		场景：要求一个类仅有一个对象（共享数据/创建消耗的资源过多/大量的静态）
	1		|	单例模式	  |		优点：减少内存开支、性能开销、避免多重占用
			|  SingletonMode  |		缺点：没有接口、扩展困难（不符合开闭原则）
			|				  |			  与单一职责原则有冲突
			|				  |		注：饿汉模式（直接实例化）、懒汉模式（构造函数中实例化）、
			|                 |			双检测锁（线程安全）
---------------------------------------------------------------------------------------------------------
			|				  |		定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类、
			|				  |			类的实例化延迟到子类
	2		|	工厂模式	  |		场景：是new的替代品，在需要生成对象的地方都可以使用
			|  FactoryMode	  |		优点：良好的封装性、代码接口清晰、扩展性好、屏蔽产品类、耦合性低
			|				  |		缺点：增加了系统复杂度
---------------------------------------------------------------------------------------------------------
			|				  |		定义：为撞见一组相关或相互依赖的对象提供一个接口，无需指定具体类
			|				  |		场景：一个对象族都有相同的约束则可以使用
	3		|	抽象工厂模式  |		优点：封装性、产品组内的约束为非公开状态
			|  AbstractFactory|		缺点：产品族扩展困难（违反开闭原则）
			|				  |		注意：产品族扩展困难，但产品等级是容易扩展的
---------------------------------------------------------------------------------------------------------
	4		|	模板方法模式  |
			|  TemplateMode   |
---------------------------------------------------------------------------------------------------------
	5		|	建造者模式	  |
			|  BuilderMode    |
---------------------------------------------------------------------------------------------------------
	6		|	代理模式	  |
			|   AgentMode     |
---------------------------------------------------------------------------------------------------------
	7		|	原型模式	  |
			|  PrototypeMode  |
---------------------------------------------------------------------------------------------------------
	8		|	中介者模式	  |
			| IntermediaryMode|
---------------------------------------------------------------------------------------------------------
	9		|	命令模式	  |
			|  CommandMode    |
---------------------------------------------------------------------------------------------------------
	10		|	责任链模式	  |
			|  Responsibility |
---------------------------------------------------------------------------------------------------------
	11		|	装饰模式	  |
			|  DecorativeMode |
---------------------------------------------------------------------------------------------------------
	12		|	策略模式	  |
			|   PolicyMode    |
---------------------------------------------------------------------------------------------------------
			|				  |		定义：将一个接口变成客户端期待的另一种接口。
			|				  |		使用场景：有动机修改一个已经投产的接口时
	13		|	适配器模式	  |		优点：提高了类的服用，增肌了透明度，灵活性好
			|   AdapterMode   |		缺点：使系统凌乱不容易把握
			|				  |		类适配器（作为基类）、对象适配器（属性/构造依赖注入）
---------------------------------------------------------------------------------------------------------
			|				  |		定义：提供一种方法访问一个容器对象中的各个元素而不暴露细节
	14		|	迭代器模式	  |		使用场景：遍历一个聚合对象
			|  IteratorMode   |		优点：支持多种遍历方法、简化了聚合类	
			|				  |		缺点：存储与遍历职责分离、新聚合增加了新迭代
			|				  |		注：指向下一个元素、删除、查看下一个、判断下一个是否存在等
---------------------------------------------------------------------------------------------------------
			|				  |		定义：将对象组合成树形结构以表示“整体-部分”的层次结构
			|				  |		使用场景：维护和展示部分-整体关系的场景
	15		|	 组合模式	  |			从一个整体中能够独立出部分模块或功能的场景
			|  CombinedMode   |		优点：高层次模块调用简单、结点自由增加
			|				  |		缺点：没有接口 与依赖导致原则冲突
			|				  |		注：透明模式和安全模式（组合操作的方法在基类中的是透明模式）
---------------------------------------------------------------------------------------------------------