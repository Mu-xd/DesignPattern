说明文件：

-----------------------------------------------------------------------------------------------------------------
	序号	|		名称	  |		内容
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：确保某一个类只有一个实例，并自行实例化向整个系统提供这个实例		
			|				  |		场景：要求一个类仅有一个对象（共享数据/创建消耗的资源过多/大量的静态）
	1		|	单例模式	  |		优点：减少内存开支、性能开销、避免多重占用
			|  SingletonMode  |		缺点：没有接口、扩展困难（不符合开闭原则）
			|				  |			  与单一职责原则有冲突
			|				  |		注：饿汉模式（直接实例化）、懒汉模式（构造函数中实例化）、
			|                 |			双检测锁（线程安全）
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类、
			|				  |			类的实例化延迟到子类
	2		|	工厂模式	  |		场景：是new的替代品，在需要生成对象的地方都可以使用
			|  FactoryMode	  |		优点：良好的封装性、代码接口清晰、扩展性好、屏蔽产品类、耦合性低
			|				  |		缺点：增加了系统复杂度
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：为撞见一组相关或相互依赖的对象提供一个接口，无需指定具体类
			|				  |		场景：一个对象族都有相同的约束则可以使用
	3		|	抽象工厂模式  |		优点：封装性、产品组内的约束为非公开状态
			|  AbstractFactory|		缺点：产品族扩展困难（违反开闭原则）
			|				  |		注意：产品族扩展困难，但产品等级是容易扩展的
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：定义一个操作中的算法框架，而将一些步骤延迟到子类中，使子类可以
			|				  |			不改变一个算法的结构即可重定义改算法的特定步骤
	4		|	模板方法模式  |		场景：多个子类有基本相同的公有方法、核心算法、重构时
			|  TemplateMode   |		优点：封装不变扩展可变、提取公共代码便于维护、行为由父类控制子类实现
			|				  |		缺点：子类影响父类结果，影响可读性
			|				  |		注：可以实现父类依赖子类的场景
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：将一个复杂对象的构建与它的表示分离，使得同样的建造过程可以创建不同表示
			|				  |		场景：复杂对象的创建工作、基类不变组合常变化时、相同方法不同顺序、装配
	5		|	建造者模式	  |		优点：封装性、建造者独立开闭原则、便于控制细节风险
			|  BuilderMode    |		缺点：
			|				  |		注意：关注的时零件类型和装配顺序
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：为其他对象提供一种代理以控制对这个对象的访问（一个类中代表
			|				  |			另一个类的功能）
			|	代理模式	  |		角色：抽象主题角色、具体主题角色、代理主题角色
	6		|   AgentMode     |		场景：访问一个类时做一些控制
			|				  |		优点：职责清晰、高扩展性、智能化
			|				  |		缺点：可能造成请求处理速度变慢、额外工作实现复杂
			|				  |		扩展：普通代理（只知道代理）、强制代理（只知道角色）、动态代理（AOP）
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
			|				  |		场景：资源优化场景、性能和安全性高、一个对象多个修改者
	7		|	原型模式	  |			解决运行期间创建和删除原型
			|  PrototypeMode  |		优点：性能优良、避免否早函数的约束
			|				  |		注意：构造函数不会被执行、浅拷贝和深拷贝
			|				  |
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：用一个中介对象封装一些列的对象交互，中戒指使各个对象不需要显式地
			|				  |			相互作用，从而使其松耦合，可以独立的改变他们之间的交互
	8		|	中介者模式	  |		角色：抽象中介者、具体中介者、同时角色（每一个同时角色都知道中介者角色）
			| IntermediaryMode|		场景：多个对象之间紧密耦合的情况（类图中出现蜘蛛网状结构）
			|				  |		优点：减少类间的依赖
			|				  |		缺点：中介者膨胀、逻辑复杂
			|				  |		注意：关注的类之间的关系
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：将一个请求封装成一个对象，从而让使用不同的请求把科幻参数化，
			|				  |			对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能
	9		|	命令模式	  |		角色：接收者（执行方）、命令角色、调用者（发布者）
			|  CommandMode    |		优点：类间解耦、可扩展性、
			|				  |		缺点：Command子类膨大（每个命令都是Command子类）
			|				  |		扩展：增加需求、反悔问题
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：使多个对象都有机会处理请求从而避免了请求的发送者和接受者之间的耦合关系
			|				  |			将这些对象连成一条链，并沿着这条链传递该请求，知道有对象处理或链结束
	10		|	责任链模式	  |		优点：请求和处理分开
			|  Responsibility |		缺点：性能问题、调试不方便
			|				  |		注意：需要控制节点数量，避免超出长度
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：动态地给对象添加一些额外的职责。就增加功能来说装饰模式相比生成子类更灵活
			|				  |		角色：抽象构件、具体构件、装饰角色、具体装饰模式
	11		|	装饰模式	  |		优点：装饰类和被装饰类可以独立发展、替代继承的方式、动态扩展一个实现类的功能
			|  DecorativeMode |		缺点：多层装饰是比较复杂的
			|				  |		场景：需要扩展类的功能、动态地增加或撤销对象功能、为一批兄弟类进行改装和加装
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：定义一组算法将每个算法都封装起来使它们之间可以互换
			|				  |		角色：封装角色、抽象策略角色、具体策略模式
	12		|	策略模式	  |		场景：多个类在算法或行为上稍有不同的场景、算法需要自有切换的场景、
			|   PolicyMode    |			需要屏蔽算法规则的场景
			|				  |		优点：算法自由切换、避免使用多重条件判断、扩展性良好
			|				  |		缺点：策略类膨胀、所有策略类都需要对外暴露
			|				  |		注意：超过四个策略需要考虑混合模式
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：将一个接口变成客户端期待的另一种接口。
			|				  |		使用场景：有动机修改一个已经投产的接口时
	13		|	适配器模式	  |		优点：提高了类的服用，增肌了透明度，灵活性好
			|   AdapterMode   |		缺点：使系统凌乱不容易把握
			|				  |		类适配器（作为基类）、对象适配器（属性/构造依赖注入）
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：提供一种方法访问一个容器对象中的各个元素而不暴露细节
	14		|	迭代器模式	  |		使用场景：遍历一个聚合对象
			|  IteratorMode   |		优点：支持多种遍历方法、简化了聚合类	
			|				  |		缺点：存储与遍历职责分离、新聚合增加了新迭代
			|				  |		注：指向下一个元素、删除、查看下一个、判断下一个是否存在等
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：将对象组合成树形结构以表示“整体-部分”的层次结构
			|				  |		使用场景：维护和展示部分-整体关系的场景
	15		|	 组合模式	  |			从一个整体中能够独立出部分模块或功能的场景
			|  CombinedMode   |		优点：高层次模块调用简单、结点自由增加
			|				  |		缺点：没有接口 与依赖导致原则冲突
			|				  |		注：透明模式和安全模式（组合操作的方法在基类中的是透明模式）
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态。
			|				  |			所有依赖于它的对象都会得到通知并被自动更新
	16		|	观察者模式	  |		使用场景：可拆分的关联行为场景、事件多级触发场景、跨系统的都消息交换
			|  ObserverMode   |		优点：观察者和被观察者之间抽象耦合、建立了一套触发机制
			|				  |		缺点：一般采用异步分方式、效率低不易调试
			|				  |		注意：广播链问题（建议消息最多转发一次）、异步处理问题
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行
			|				  |			提供了一个高层次的接口，使子系统更容易使用
	17		|	外观模式	  |		场景：为复杂模块体统一个供外界访问的接口、子系统黑箱访问
			|  FacadeMode     |		优点：减少系统相互依赖、提高了灵活性、提高安全性
			|				  |		缺点：不符合开闭原则。
			|				  |		注意：一个子系统可以有多个门面、门面不参与子系统内的业务逻辑
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态
			|				  |			这样以后就可以将该对象恢复到原先保存的状态
	18		|	备忘录模式	  |		场景：需要保存和恢复数据的相关状态、可回滚操作、需要监控的副本、数据库事务
			|	 MemoMode     |		注意：生命周期（最近的代码中使用）、性能（不在频繁简历备份的场景中使用）
			|				  |		扩展：clone方式、多状态的备忘录模式、多备份的备忘录、接口设计（相对的数据安全）
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：封装一些作用于某种数据结构中的各元素操作，在不改变数据结构的前提
			|				  |			下定义作用于这些元素的新的操作
	19		|	访问者模式	  |		角色：抽象访问者、具体访问者、抽象元素、具体元素、结构对象（产生不同的具体元素）
			|  VisitorMode    |		场景：对一个对象结构中对象进行不同且不相关的操作、迭代器模式不能胜任
			|				  |		优点：单一职责、扩展性、灵活性
			|				  |		缺点：具体元素对访问者公布细节、具体元素变更困难、违背了依赖倒置原则
			|				  |		扩展：统计功能、多个访问者、双分派
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：当一个对象内在的状态改变时允许其改变行为，这个对象看起来像改变了其类
			|				  |		角色：抽象状态角色、具体状态角色、环境角色（状态声明为静态常量、具有状态角色
			|	状态模式	  |			的所有行为）
	20		|   StateMode     |		优点：结构清晰、遵循设计原则、封装性好、
			|				  |		缺点：子类太多，类膨胀
			|				  |		场景：行为随状态改变而改变的场景、条件/分支判断语句的替代者
			|				  |		注意：使用时对象的状态最好不超过5个
-----------------------------------------------------------------------------------------------------------------
			|				  |		定义：给定一门语言，定义它的文法的一种表示，并定义一个解释，该解释器使用该表示
			|				  |			来解释语言中的句子
			|	解释器模式	  |		角色：抽象解释器、终结符表达式（Var）、非终结符表达式（文法规则）、环境角色
	21		| InterpreterMode |		优点：扩展性
			|				  |		缺点：类膨胀、递归（调试复杂，性能）、效率问题
			|				  |		场景：重复发生的问题、简单语法
			|				  |		注意：维护困难、不要在虫咬模块中使用
-----------------------------------------------------------------------------------------------------------------