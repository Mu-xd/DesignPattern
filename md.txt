
---------------------------------------------------------------------------------------------------------
	序号	|		名称	  |		内容
---------------------------------------------------------------------------------------------------------
			|				  |		定义：确保某一个类只有一个实例，并自行实例化向整个系统提供这个实例		
			|				  |		场景：要求一个类仅有一个对象（共享数据/创建消耗的资源过多/大量的静态）
	1		|	单例模式	  |		优点：减少内存开支、性能开销、避免多重占用
			|  SingletonMode  |		缺点：没有接口、扩展困难（不符合开闭原则）
			|				  |			  与单一职责原则有冲突
			|				  |		注：饿汉模式（直接实例化）、懒汉模式（构造函数中实例化）、
			|                 |			双检测锁（线程安全）
---------------------------------------------------------------------------------------------------------
			|				  |		定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类、
			|				  |			类的实例化延迟到子类
	2		|	工厂模式	  |		场景：是new的替代品，在需要生成对象的地方都可以使用
			|  FactoryMode	  |		优点：良好的封装性、代码接口清晰、扩展性好、屏蔽产品类、耦合性低
			|				  |		缺点：增加了系统复杂度
---------------------------------------------------------------------------------------------------------
			|				  |		定义：为撞见一组相关或相互依赖的对象提供一个接口，无需指定具体类
			|				  |		场景：一个对象族都有相同的约束则可以使用
	3		|	抽象工厂模式  |		优点：封装性、产品组内的约束为非公开状态
			|  AbstractFactory|		缺点：产品族扩展困难（违反开闭原则）
			|				  |		注意：产品族扩展困难，但产品等级是容易扩展的
---------------------------------------------------------------------------------------------------------
			|				  |		定义：定义一个操作中的算法框架，而将一些步骤延迟到子类中，使子类可以
			|				  |			不改变一个算法的结构即可重定义改算法的特定步骤
	4		|	模板方法模式  |		场景：多个子类有基本相同的公有方法、核心算法、重构时
			|  TemplateMode   |		优点：封装不变扩展可变、提取公共代码便于维护、行为由父类控制子类实现
			|				  |		缺点：子类影响父类结果，影响可读性
			|				  |		注：可以实现父类依赖子类的场景
---------------------------------------------------------------------------------------------------------
			|				  |		定义：将一个复杂对象的构建与它的表示分离，使得同样的建造过程可以创建不同表示
			|				  |		场景：复杂对象的创建工作、基类不变组合常变化时、相同方法不同顺序、装配
	5		|	建造者模式	  |		优点：封装性、建造者独立开闭原则、便于控制细节风险
			|  BuilderMode    |		缺点：
			|				  |		注意：关注的时零件类型和装配顺序
---------------------------------------------------------------------------------------------------------
	6		|	代理模式	  |
			|   AgentMode     |
---------------------------------------------------------------------------------------------------------
	7		|	原型模式	  |
			|  PrototypeMode  |
---------------------------------------------------------------------------------------------------------
	8		|	中介者模式	  |
			| IntermediaryMode|
---------------------------------------------------------------------------------------------------------
	9		|	命令模式	  |
			|  CommandMode    |
---------------------------------------------------------------------------------------------------------
	10		|	责任链模式	  |
			|  Responsibility |
---------------------------------------------------------------------------------------------------------
	11		|	装饰模式	  |
			|  DecorativeMode |
---------------------------------------------------------------------------------------------------------
	12		|	策略模式	  |
			|   PolicyMode    |
---------------------------------------------------------------------------------------------------------
			|				  |		定义：将一个接口变成客户端期待的另一种接口。
			|				  |		使用场景：有动机修改一个已经投产的接口时
	13		|	适配器模式	  |		优点：提高了类的服用，增肌了透明度，灵活性好
			|   AdapterMode   |		缺点：使系统凌乱不容易把握
			|				  |		类适配器（作为基类）、对象适配器（属性/构造依赖注入）
---------------------------------------------------------------------------------------------------------
			|				  |		定义：提供一种方法访问一个容器对象中的各个元素而不暴露细节
	14		|	迭代器模式	  |		使用场景：遍历一个聚合对象
			|  IteratorMode   |		优点：支持多种遍历方法、简化了聚合类	
			|				  |		缺点：存储与遍历职责分离、新聚合增加了新迭代
			|				  |		注：指向下一个元素、删除、查看下一个、判断下一个是否存在等
---------------------------------------------------------------------------------------------------------
			|				  |		定义：将对象组合成树形结构以表示“整体-部分”的层次结构
			|				  |		使用场景：维护和展示部分-整体关系的场景
	15		|	 组合模式	  |			从一个整体中能够独立出部分模块或功能的场景
			|  CombinedMode   |		优点：高层次模块调用简单、结点自由增加
			|				  |		缺点：没有接口 与依赖导致原则冲突
			|				  |		注：透明模式和安全模式（组合操作的方法在基类中的是透明模式）
---------------------------------------------------------------------------------------------------------
			|				  |		定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态。
			|				  |			所有依赖于它的对象都会得到通知并被自动更新
	16		|	观察者模式	  |		使用场景：可拆分的关联行为场景、事件多级触发场景、跨系统的都消息交换
			|  ObserverMode   |		优点：观察者和被观察者之间抽象耦合、建立了一套触发机制
			|				  |		缺点：一般采用异步分方式、效率低不易调试
			|				  |		注意：广播链问题（建议消息最多转发一次）、异步处理问题
---------------------------------------------------------------------------------------------------------
			|				  |		定义：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行
			|				  |			提供了一个高层次的接口，使子系统更容易使用
	17		|	外观模式	  |		场景：为复杂模块体统一个供外界访问的接口、子系统黑箱访问
			|  FacadeMode     |		优点：减少系统相互依赖、提高了灵活性、提高安全性
			|				  |		缺点：不符合开闭原则
			|				  |		注意：一个子系统可以有多个门面、门面不参与子系统内的业务逻辑
---------------------------------------------------------------------------------------------------------
			|				  |		定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态
			|				  |			这样以后就可以将该对象恢复到原先保存的状态
	18		|	备忘录模式	  |		场景：需要保存和恢复数据的相关状态、可回滚操作、需要监控的副本、数据库事务
			|	 MemoMode     |		注意：生命周期（最近的代码中使用）、性能（不在频繁简历备份的场景中使用）
			|				  |		扩展：clone方式、多状态的备忘录模式、多备份的备忘录、接口设计（相对的数据安全）
---------------------------------------------------------------------------------------------------------